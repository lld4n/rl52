---
title: eval()
date: 2023-11-05
---
> [[#Нельзя использовать eval()]]
## Определение
Оценивает код JavaScript, представленный в виде строки, и возвращает значение завершения. Исходный код анализируется как скрипт

Аргументом функции `eval()`является строка. Он будет оценивать исходную строку как тело сценария, что означает, что разрешены как операторы, так и выражения. Он возвращает значение завершения кода. Если аргумент `eval()`не является строкой, `eval()`возвращает аргумент без изменений.

В строгом режиме объявление переменной с именем `eval`или ее переназначение `eval`представляет собой файл [[SyntaxError]]

## Синтаксис
```js
eval(script)
```

## Прямой и косвенный
Прямой - вызов функции `eval()` через глобальный объект, все остальное - косвенный

Косвенный можно расценивать как отдельный `<script>`

- Косвенная оценка работает в глобальной области, а не в локальной, и оцениваемый код не имеет доступа к локальным переменным в области, в которой он вызывается
- Косвенный не наследует строгость окружающего контекста и будет находиться в строгом режиме только в том случае, если исходная строка имеет `use strict`


## Нельзя использовать eval()
- `eval()`выполняет переданный код с привилегиями вызывающего объекта. Если вы запустите `eval()`строку, на которую может повлиять злоумышленник, вы можете в конечном итоге запустить вредоносный код на компьютере пользователя с разрешениями вашей веб-страницы или расширения. Что еще более важно, предоставление стороннему коду доступа к области, в которой он `eval()`был вызван (если это прямая оценка), может привести к возможным атакам, которые читают или изменяют локальные переменные.
- `eval()`медленнее, чем альтернативы, поскольку он должен вызывать интерпретатор JavaScript, в то время как многие другие конструкции оптимизированы современными движками JS.
- Современные интерпретаторы JavaScript преобразуют JavaScript в машинный код. Это означает, что любая концепция именования переменных стирается. Таким образом, любое использование `eval()`заставит браузер выполнять долгие и дорогостоящие поиски имен переменных, чтобы выяснить, где эта переменная находится в машинном коде, и установить ее значение. 
- Минификаторы отказываются от минимизации, если область видимости транзитивно зависит от `eval()`, поскольку в противном случае `eval()`невозможно прочитать правильную переменную во время выполнения.