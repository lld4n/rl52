---
title: Объекты
date: 2023-11-02
---
## Определение
**Объект** - это совокупность связанных данных и/или функциональных возможностей. Состоят из свойств (переменных) и методов (функций)
```js
const person = {
  name: ["Bob", "Smith"],
  age: 32,
  gender: "male",
  interests: ["music", "skiing"],
  bio: function () {
    alert(
      this.name[0] +
        " " +
        this.name[1] +
        " is " +
        this.age +
        " years old. He likes " +
        this.interests[0] +
        " and " +
        this.interests[1] +
        ".",
    );
  },
  greeting: function () {
    alert("Hi! I'm " + this.name[0] + ".");
  },
};
```

## Обращение к объектам
Существует три типа записи к объектам:
- Точечная запись
	- `person.age`
	- `person.bio()`
- Запись в скобках
	- `person["age"]`
	- `person["name"]["first"]`
- Оператор опциональной последовательности
	- `person.?age`
	- Работает подобно оператору `.`, за исключением того, что не выбрасывает исключение, если объект, к свойству или методу которого идет обращение, равен [[null]] или [[undefined]]. В этих случаях он возвращает [[undefined]]

## Проверить наличие ключа
Для проверки наличия ключа можно использовать `... in ...`. Можно также использовать `... === undefined`, но оно не сработает, если значение ключа равно [[undefined]], поэтому лучше использовать `in`

## Перебрать все ключи в объекте
Перебрать все ключи в объекте можно с помощью `for (let key in ...)`, где `key` будет равен попорядку ключом из объекта

## Прототипы
Механизм, с помощью которого объекты наследуют функции друг от друга. Каждый объект имеет встроенное свойство, которое называется его прототипом. Свойство объекта, указывающее на его прототип, не называетя `prototype`. Его имя нестандартное, но на практике все браузеры используют расширение `__proto__`

Когда пытаешься получить доступ к свойству объекта: если свойство не может быть найдено в самом объекте, выполняется поиск свойства в прототипе рекурсивно. Если даже так найти не получилось, то будет возвращено [[undefined]]

Если какому-то объекту задать метод, который уже есть в его прототипе, то он его добавит в прототип экземляра. И в дальнейшем при использовании будет использоваться добавленный метод, так как при поиске метода мы спускаемся вниз рекурсивно, пока не найдем метод

## Стандартные объекты
- Свойства значений
	- [[globalThis]]
	- [[Infinity]]
	- [[NaN]]
	- [[undefined]]
- Свойства функции
	- [[eval()]]
	- [[isFinite()]]
	- [[isNaN()]]
	- [[parseFloat()]]
	- [[parseInt()]]
	- [[decodeURI()]]
	- [[decodeURIComponent()]]
	- [[encodeURI()]]
	- [[encodeURIComponent()]]
- Фундаментальные объекты
	- [[Object]]
	- [[Function]]
	- [[Boolean]]
	- [[Symbol]]
- Объекты ошибок
	- [[Error]]
	- [[AggregateError]]
	- [[EvalError]]
	- [[RangeError]]
	- [[ReferenceError]]
	- [[SyntaxError]]
	- [[TypeError]]
	- [[URIError]]
- Числа и даты
	- [[Number]]
	- [[BigInt]]
	- [[Math]]
	- [[Date]]
- Обработка текста
	- [[String]]
	- [[RegExp]]
- Индексированные коллекции
	- [[Array]]
	- [[Типизированный массив]] #ES6 
- Коллекции с ключами #ES6 
	- [[Map]]
	- [[Set]]
	- [[WeakSet]]
	- [[WeakMap]]
- Структурированные данные
	- [[ArrayBuffer]]
	- [[SharedArrayBuffer]]
	- [[DataView]]
	- [[Atomics]]
	- [[JSON]]
- Управлению памятью
	- [[WeakRef]]
	- [[FinalizationRegistry]]
- Управление объектами абстракции
	- [[Iterator]]
	- [[AsyncIterator]]
	- [[Promise]]
	- [[GeneratorFunction]]
	- [[AsyncGeneratorFunction]]
	- [[Generator]]
	- [[AsyncGenerator]]
	- [[AsyncFunction]]
- Метапрограммирование
	- [[Reflect]]
	- [[Proxy]]
- [[Интернационализация]]