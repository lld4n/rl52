---
title: tsconfig
date: 2023-11-13
---
## Создание
Создать `tsconfig` можно с помощью команды `tsc --init`. Это создаст файл `tsconfig.json` в корневой директории. Внутри настроек `tsconfig` существует несколько секций. Главная из них - это секция root

## Идеальный tsconfig
его не существует, все зависит от случая

## Секция root
### extends
Указывает путь к файлу из которого нужно унаследовать опции. Служит инструментом упорядочивания. Пример использования - это настройки для dev режима. То есть мы можем переопределять настройки
```json
{ 
	"extends": "./tsconfig.json", 
	"compilerOptions": {
		/* переопределяем настройки */
		"sourceMap": true, 
		"watch": true 
	} 
}
```
### files
Указывает на список конкретных файлов для компиляции
```json
{
	"compillerOptions": {},
	"files": [
		"core.ts",
		"app.ts"
	]
}
```
### include
Связана с `files` и `exclude`. В случае, если `files` не указан, то `ts` смотрит на запись в `include`. Если `include` не указан, то `ts` будет рассматривать все файлы внутри корневой директории, что является не оптимальным, так как тогда он будет просматривать все файлы. Можно указывать не только конкретные файлы, но и паттерны. Если в паттернах не указать тип файла, то будут рассматриваться расширения `.ts`, `.tsx`, `.d.ts`
```json
{
  "compilerOptions": {},
  "include": [
    "src/**/*",
    "tests/**/*"
  ]
}
```

Технически `ts` сгенерирует список всех подходящих файлов и поместит их в `files`, поэтому можно посмотреть на эти файлы с помощью команды `tsc --showConfig`
### exclude
Исключает лишние пути и файлы, которые включились директивой `include`. По умолчанию исключает `node_modules`, `bower_components`, `jspm_packages`, а также если указан `outDir`. Важно, что если изменять это свойство, то нужно указывать `node_modules` вручную
```json
{ 
	"compilerOptions": {}, 
	"exclude": [ 
		"node_modules", 
		"./src/**/*.spec.ts" 
	] 
}
```
## Секция compilerOptions
Здесь хранятся все основные настройки `ts`
### target
Строка. Указывает версию `js` в которую будет скомпилирован `ts`. По умолчанию `ES3`
### module
Строка. Модульная система. Если нужна поддержка `requiere` то нужно указать `CommonJS`
### moduleResolution
Строка. Принимает либо `node`, либо `classic`. Но `classic` - это легаси, поэтому лучше всего поставить `node` и не ломать мозг. По умолчанию зависит от `module`
### lib
Массив строк. В зависимости от того какой `target` установлен в конфиге, TypeScript подключает тайпинги (`*.d.ts-файлы`) для поддержки соответствующих спецификаций. Например, если ваш `target` установлен в `ES6`, то TypeScript подключит поддержку `array.find` и прочих вещей, которые есть в стандарте. Но если `target` стоит `ES5`, то использовать метод массива `find` нельзя, так как его не существует в этой версии JavaScript. Можно подключить полифилы. Однако, для того, чтобы TypeScript понял, что теперь данную функциональность можно использовать, необходимо подключить необходимые тайпинги в секции `lib`. При этом, можно подключить как весь стандарт `ES2015`, так и его часть `ES2015.Core` (только методы `find`, `findIndex` и т. д.).

Конечно, правильным выбором будет подключать тайпинги только той функциональности, для которой установлены полифилы

```
Для --target ES5 подключаются: DOM, ES5, ScriptHost
Для --target ES6: DOM, ES6, DOM.Iterable, ScriptHost
```

_Как только вы что-либо добавляете в_ `lib` умолчания сбрасываются. Необходимо руками добавить то, что нужно, например `DOM`_:_

```json
{
  "compilerOptions": {
    "target": "ES5",
    "lib": [
      "DOM",
      "ES2015.Core"
    ]
  }
}
```
### outDir
Строка. Указывает на папку, куда будут складываться файлы после сборки. Если не указать, то файлы будут складываться по такому же пути. Например `src/index.ts` будет собран в файл `src/index.js`. Относится к файлам `.js`, `.d.ts`, `.js.map`
### outFile
Строка. Должно работать как `webpack` (то есть собирать все файлы в один), но к сожалению работает только при `module` указанным `None`, `System`, `AMD`. С `ES6` не работает. Поэтому лучше не использовать
### allowSyntheticDefaultImports
Флаг. Если какая-либо библиотека не имеет `default import`, лоадеры вроде `ts-loader` или `babel-loader` автоматически создают их. Однако, `d.ts-файлы` библиотеки об этом не знают. Данный флаг говорит компилятору, что можно писать следующим образом:

```ts
// вместо такого импорта
import * as React from 'react';
// можно писать такой
import React from 'react';
```

_Опция включена по умолчанию, если включен флаг_ `esModuleInterop` _или_ `module === "system"`

### esModuleInterop
Флаг. За счёт добавления болерплейта в выходной код, позволяет импортировать `CommonJS` пакеты как `ES6`.

```ts
// библиотека moment экспортируется только как CommonJS
// пытаемся импортировать её как ES6
import Moment from 'moment';

// без флага esModuleInterop результат undefined
console.log(Moment);

// c флагом результат [object Object]
console.log(Moment);
```

Данный флаг по зависимости активирует `allowSyntheticDefaultImports`. Вместе они помогают избавиться от зоопарка разных импортов и писать их единообразно по всему проекту.
### downleveliteration
Флаг. Выдает более совместимый, но многословный и менее производительный JavaScript для итераций
### forceConsistentCasignInFileNames
Флаг. Включает режим чувствительности к регистру во время импорта файлов. То есть запрещает импорт если название файла не совпадает с оригинальным с учетом регистра
### declaration
Флаг. Включает генерацию файлов-аннотаций `.d.ts`. Используется вовремя публикации на `npm`
### declarationDir
Строка. По умолчанию `.d.ts` создаются рядом с `js` файлами. Чтобы это изменить нужно указать название директории
### emitDeclarationOnly
Флаг. Если нужно скомпилировать только `.d.ts`, то есть включенный флаг предотвращает компиляцию `js` файлов
### allowJs
Флаг. Компилятор будет учитывать не только `ts` файлы, но и `js` файлы
### checkJs
Флаг. TypeScript будет проверять ошибки не только в `ts`, но и в `js`-файлах. Помимо встроенных тайпингов для языковых конструкций JavaScript, TS-компилятор так же умеет использовать jsDoc для анализа файлов
### resolveJsonModule
Флаг. Позволяет включить возможность импортировать `.json` файлы
### jsx
Флаг. Если проект использует `React` необходимо обязательно включить
## Strict Checks
### strict
Флаг. Включает все флаги из секции `strict checks`. В этом есть недостаток: непонимание, какие правила включены, а какие нет. Плюс при обновление могут включаться новые флаги
### alwaysStrict
Флаг. Компилятор будет парсить в строгом режиме. Добавляет во все файлы `use strict`
### noImplicitAny
Флаг. Указывает на отсутствие явно указанного типа `any`. То есть если не указать тип, то он автоматом становится `any`. TypeScript будет на это ругаться, так как он хочет, чтобы тип `any` был указан явно, чтобы разработчики понимали, что в определенной части кода недоработка
### strictNullChecks
Флаг. JavaScript содержит два нижних значения – `undefined` и `null`, для которых в TypeScript есть одноимённые типы. По иерархии считается, что все остальные типы происходят от них. Таким образом по принципу наследования вместо переменной любого типа: `string`, `boolean`, `number` и т. д – можно передать значение `undefined` или `null`:

```ts
function someFunction (value: number) {
  // можно получить неожиданный результат если value будет undefined или null
  return value * 2
}

someFunction(5)
// по умолчанию можно так
someFunction(null)
// и можно так
someFunction(undefined)
```

Подобное поведение справедливо для почти всех (если не всех) языков программирования. На практике это может вызывать неудобства в виде написания дополнительных проверок на `null` (`undefined`)

Включение опции `strictNullChecks` меняет правила игры. С данным флагом компилятор больше не позволяет передавать `undefined` или `null` туда, где ожидаются переменные других типов, если это не разрешено явно. Рассмотрим пример:

```ts
function someFunction (value: number) {
  // value всегда будет только number
  return value * 2
}

someFunction(5)
// следующие вызовы функции невозможны
someFunction(null)
someFunction(undefined)
```

Это позволяет не обрабатывать ситуации с `undefined` и `null` в тех участках кода, где возникновение данных значений невозможно. При этом в тем местах, где возникновение подобных ситуаций возможно, компилятор не позволит забыть о проверках. Это очень сильный механизм, существование которого сложно переоценить.

```ts
// Символ «?» разрешает undefined, а «| null» - null
function someFunction (value?: number | null) {
  if (value == null) {
    return 0
  }
  return value * 2
}
```

Однако бывают случаи, когда данные получаются динамически, в таком случае может прийти `null`
### strictPropertyInitialization
Флаг. Проверяет, что объявленные свойства класса были инициализированы
### strictFunctionTypes
Флаг. Включает более строгую проверку сигнатур функций
### noImplicitThis
Флаг. При использовании `this` проверяет, что контекст выполнения известен
### strictBindCallApply
Флаг. Включает более строгую проверку сигнатур при использовании соответствующих методов: `bind`, `call`, `apply` 
## Linter Checks 
### noPropertyAccessFromIndexSignature
Флаг. Запрещает обращение к свойствам объекта через точку, если свойства объекта описаны не явно, а через произвольные параметры
```ts
interface User { 
	// явно указанные параметры
	login: string 
	email: string 

	// произвольные параметры 
	[key: string]: string 
} 
const user: User = { 
	login: 'hello', 
	email: 'hello@example.com' 
} 
// c noPropertyAccessFromIndexSignature: true 
// данная строка приведёт к ошибке 
const username = user.name 
// но так обращаться всё ещё можно 
const username2 = user['name']
```
### noUncheckedIndexedAccess
Флаг. Лучше не использовать, так как создает дополнительные проблемы. Чет нихуя не понял, в принципе можно забить и не использовать
### noImplicitReturns
Флаг. Проверяет, чтобы все ветки функции возвращали значение
### noFallthroughCasesInSwitch
Флаг. Проверяет наличие `break` в конструкции `switch/case`
### noUnusedLocals
Флаг. Проверяет на наличие неиспользуемых переменных
### noUnusedParameters
Флаг. Проверяет на наличие неиспользуемых аргументов функции и методов
## Advanced
### allowUnreachableCode
Флаг. По умолчанию `true`. Запрещает недосягаемый код, то есть код, который находится после `return`, `break` и тд
### allowUnusedLabels
нахуй не нужно, забей
### noImplicitUseStrict
нахуй не нужно, забей. Флаг автоматически добавляет `"use strict"` если `target` версия меньше, чем `ES6`. Опция `alwaysStrict` в свою очередь делает тоже самое, но для любых `target`. Вряд ли когда-нибудь возникнет необходимость переопределять значение данного флага.

Если же обоим флагам `noImplicitUseStrict` и `alwaysStrict` установить значение `true`, то возникнет ошибка компиляции, так как настройки противоречат друг другу.
### suppressExcessPropertyErrors
Флаг. Лучше не трогать. Проверяет, чтобы объект не мог содержать свойства, которые не были описаны в его структуре
### suppressImplicitAnyIndexErrors
Флаг. По умолчанию `false`. Проверяет, что используя скобочную нотацию невозможно обращаться к свойствам объекта, которые в нем не объявлены ни явно, ни через произвольные параметры
### noStrictGenericChecks
нихуя не понял, лучше не трогать

